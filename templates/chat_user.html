<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chat with {{ other_user }}</title>
  <style>
    /* [Existing CSS Styles] */
    body {
      font-family: Arial, sans-serif;
      background-color: #f4f4f4;
      margin: 0;
      padding: 0;
    }

    /* Top bar solely for the back button */
    .top-bar {
      height: 50px;
      background: #fafafa;
      border-bottom: 1px solid #ddd;
      position: relative;
    }
    .back-btn {
      position: absolute;
      left: 1rem;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      font-size: 1.6rem;
      cursor: pointer;
      color: #555;
      z-index: 10;
    }
    .back-btn:hover {
      color: #000;
    }

    .chat-container {
      width: 60%;
      max-width: 900px;
      margin: 1rem auto;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-direction: column;
      height: 80vh;
      overflow: hidden;
      position: relative;
    }

    /* Chat header (below the top bar) */
    .chat-header {
      display: flex;
      align-items: center;
      padding: 1rem;
      border-bottom: 1px solid #ddd;
      background-color: #fafafa;
      position: relative;
    }
    .chat-header img {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      margin-right: 1rem;
      object-fit: cover;
      border: 2px solid #ccc;
    }
    .chat-header h2 {
      margin: 0;
      font-size: 1.4rem;
    }
    .chat-header .status {
      margin-left: 1rem;
      font-size: 0.9rem;
      color: #555;
    }
    .block-btn {
      background-color: #ff5252;
      border: none;
      color: white;
      padding: 0.4rem 0.8rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      position: absolute;
      right: 1rem;
      top: 1.2rem;
      z-index: 2;
    }
    .block-btn:hover {
      background-color: #ff2e2e;
    }

    .messages-wrapper {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #messages-area {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      background-color: #f9f9f9;
      position: relative;
    }

    .message {
      padding: 0.8rem 1.2rem;
      margin-bottom: 1rem;
      border-radius: 6px;
      max-width: 70%;
      clear: both;
      position: relative;
      word-wrap: break-word;
      background-color: #fff;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .message.mine {
      background-color: #e1ffc7;
      float: right;
      text-align: right;
    }
    .message.other {
      background-color: #fff;
      float: left;
      text-align: left;
    }

    .reply-preview {
      font-size: 0.9rem;
      color: #444;
      margin-bottom: 0.4rem;
      padding: 0.4rem;
      border-left: 2px solid #999;
      background-color: #f0f0f0;
      border-radius: 4px;
      margin-top: -0.2rem;
    }

    .timestamp {
      font-size: 0.75rem;
      color: #999;
      display: block;
      margin-top: 0.3rem;
    }
    .read-receipt {
      font-size: 0.75rem;
      color: #999;
      margin-left: 0.5rem;
      margin-bottom: 0.3rem;
      display: inline-block;
    }

    .action-buttons {
      position: absolute;
      bottom: 5px;
      right: 10px;
      display: flex;
      gap: 5px;
    }
    .delete-btn,
    .edit-btn,
    .reply-btn {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 0.75rem;
      outline: none;
      padding: 2px 5px;
      border-radius: 3px;
      transition: background-color 0.2s ease;
    }
    .delete-btn {
      color: red;
    }
    .delete-btn:hover {
      background-color: rgba(255, 0, 0, 0.1);
    }
    .edit-btn {
      color: #007bff;
    }
    .edit-btn:hover {
      background-color: rgba(0, 123, 255, 0.1);
    }
    .reply-btn {
      color: #888;
    }
    .reply-btn:hover {
      background-color: rgba(136, 136, 136, 0.1);
    }

    .clear {
      clear: both;
    }

    /* Reply Banner */
    #replyBanner {
      display: none;
      padding: 0.5rem;
      background: #fafbfc;
      border-left: 4px solid #ccc;
      margin: 0 1rem 1rem 1rem;
      position: relative;
    }
    #replyPreviewText {
      font-weight: bold;
      color: #333;
      margin-left: 5px;
    }

    /* Input area for text */
    #sendForm {
      display: flex;
      padding: 0.8rem;
      border-top: 1px solid #ddd;
      background-color: #fafafa;
      align-items: center;
    }
    #msgInput {
      flex: 1;
      padding: 0.5rem;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    #sendBtn {
      padding: 0.5rem 1rem;
      margin-left: 0.5rem;
      font-size: 1rem;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    #sendBtn:hover {
      background-color: #45a049;
    }
    #sendBtn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    @media (max-width: 768px) {
      .chat-container {
        width: 95%;
      }
      .message {
        max-width: 80%;
      }
    }
  </style>
</head>
<body>
  <!-- Separate top bar for back button -->
  <div class="top-bar">
    <button class="back-btn" onclick="window.location.href='/dashboard'" title="Back to Dashboard">&#8592;</button>
  </div>

  <div class="chat-container">
    <!-- Chat Header (profile, name, block button) -->
    <div class="chat-header">
      <!-- Profile Picture will be fetched via JavaScript -->
      <img src="/profile_pictures/default_profile.png" alt="Profile Picture" id="profilePicture" />
      <div>
        <h2>{{ other_user }}</h2>
        <span class="status">
          {% if other_user_status == "online" %}
            Online
          {% elif other_user_status.startswith("last seen") %}
            {{ other_user_status }}
          {% else %}  
            Status unavailable
          {% endif %}
        </span>
      </div>
      <button class="block-btn" id="blockBtn">Block</button>
    </div>

    <!-- Reply Banner -->
    <div id="replyBanner">
      Replying to:
      <span id="replyPreviewText"></span>
      <button onclick="cancelReply()" style="margin-left: 10px; cursor: pointer;">Cancel</button>
    </div>

    <div class="messages-wrapper">
      <div id="messages-area"></div>
    </div>

    <!-- Input area for text -->
    <form id="sendForm" onsubmit="return sendMessage();">
      <input type="text" id="msgInput" placeholder="Type a message..." />
      <button type="submit" id="sendBtn">Send</button>
    </form>
  </div>

  <script>
    /* ---------------------- Request Queue Implementation ---------------------- */
    let requestQueue = []; // Stores pending operations
    let isProcessing = false; // Indicates if an operation is in progress

    /**
     * Processes the next operation in the queue.
     */
    async function processQueue() {
      if (isProcessing || requestQueue.length === 0) return;

      isProcessing = true;
      const operation = requestQueue.shift(); // Get the first operation

      try {
        await operation(); // Execute the function stored in the queue
      } catch (err) {
        console.error("Error processing request:", err);
      }

      isProcessing = false;

      // Continue processing the queue
      processQueue();
    }

    /**
     * Adds an operation to the queue.
     * @param {Function} operation - An asynchronous function representing the operation.
     */
    function queueRequest(operation) {
      requestQueue.push(operation);
      console.log("Queued operation:", operation.name || "Anonymous Function");
      processQueue(); // Start processing if not already running
    }
    /* -------------------------------------------------------------------------- */

    /* ----------------------------- Chat Functionality ---------------------------- */
    let token = "{{ session['token'] }}";
    const otherUser = "{{ other_user }}";
    const currentUser = "{{ username }}";
    let nodeName = {{ node_name|tojson }};

    let refreshInProgress = false;
    let isBlocked = false;
    let otherSideBlockedUs = false;

    let currentReplyMsgId = null;
    let currentReplyPreview = null;

    /**
     * Updates the state of the send button based on block status.
     */
    function updateSendButton() {
      const sendBtn = document.getElementById("sendBtn");
      if (isBlocked || otherSideBlockedUs) {
        sendBtn.disabled = true;
      } else {
        sendBtn.disabled = false;
      }
    }

    /**
     * Refreshes the authentication token.
     */
    async function refreshToken() {
      if (refreshInProgress) return;
      refreshInProgress = true;
      console.log("Refreshing token...");
      try {
        const resp = await fetch("/refresh_token", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ token: token })
        });
        const data = await resp.json();
        if (data.token) {
          token = data.token;
          console.log("Token refreshed.");
          await fetch("/update_token", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ token: token })
          });
        } else {
          console.warn("No token received during refresh.");
        }
      } catch (err) {
        console.error("refreshToken error:", err);
      } finally {
        refreshInProgress = false;
      }
    }

    /**
     * Fetches and renders chat messages.
     */
    async function refreshMessages() {
      const payload = {
        node_name: nodeName,
        token: token,
        other_user: otherUser
      };
    
      try {
        const response = await fetch("/get_messages_via_erlang", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
    
        if (response.status === 401) {
          console.warn("Unauthorized. Refreshing token and retrying fetchMessages.");
          await refreshToken();
          // Re-queue the fetchMessages operation after token refresh
          queueRequest(refreshMessages);
          return;
        }
    
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
    
        const data = await response.json();
        if (!data || typeof data !== "object" || !data.messages) {
          console.error("Invalid JSON response from server:", data);
          return;
        }
        renderMessages(data.messages);
      } catch (err) {
        console.error("refreshMessages error:", err);
        throw err; // Re-throw to handle in the queue
      }
    }

    /**
     * Renders messages in the chat area.
     * @param {Array} messages - Array of message objects.
     */
    function renderMessages(messages) {
      const container = document.getElementById("messages-area");
      
      // Check if the user is near the bottom before updating
      const isAtBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 100;
      
      container.innerHTML = "";

      messages.forEach(msg => {
        const isMine = (msg.sender === currentUser);
        const messageDiv = document.createElement("div");
        messageDiv.classList.add("message", isMine ? "mine" : "other");

        if (msg.reply_to && msg.reply_preview) {
          const replyDiv = document.createElement("div");
          replyDiv.classList.add("reply-preview");
          replyDiv.textContent = msg.reply_preview;
          messageDiv.appendChild(replyDiv);
        }

        // Display text message
        const textSpan = document.createElement("span");
        textSpan.textContent = msg.message;
        messageDiv.appendChild(textSpan);

        if (msg.edited) {
          const editedSpan = document.createElement("span");
          editedSpan.textContent = " (edited)";
          editedSpan.style.fontStyle = "italic";
          editedSpan.style.fontSize = "0.8rem";
          messageDiv.appendChild(editedSpan);
        }

        const tsSpan = document.createElement("span");
        tsSpan.classList.add("timestamp");
        const msgDate = new Date(msg.timestamp);
        const now = new Date();
        const diffMs = now - msgDate;
        const oneDayMs = 24 * 60 * 60 * 1000;
        let formattedTime = "";
        if (diffMs < oneDayMs) {
          formattedTime = msgDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        } else {
          formattedTime = msgDate.toLocaleDateString([], {day: '2-digit', month: 'short', year: 'numeric'}) + ", " +
                          msgDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        }
        tsSpan.textContent = " " + formattedTime;
        messageDiv.appendChild(tsSpan);

        if (isMine) {
          const readReceipt = document.createElement("span");
          readReceipt.classList.add("read-receipt");
          if (msg.read_by && msg.read_by.includes(otherUser)) {
            readReceipt.textContent = "✔✔";
          } else {
            readReceipt.textContent = "✔";
          }
          messageDiv.appendChild(readReceipt);

          const actionBtns = document.createElement("div");
          actionBtns.classList.add("action-buttons");

          const delBtn = document.createElement("button");
          delBtn.classList.add("delete-btn");
          delBtn.textContent = "Delete";
          delBtn.onclick = () => deleteMessage(msg._id);
          actionBtns.appendChild(delBtn);

          const editBtn = document.createElement("button");
          editBtn.classList.add("edit-btn");
          editBtn.textContent = "Edit";
          editBtn.onclick = () => editMessage(msg._id, msg.message);
          actionBtns.appendChild(editBtn);

          const replyBtn = document.createElement("button");
          replyBtn.classList.add("reply-btn");
          replyBtn.textContent = "↩";
          replyBtn.title = "Reply";
          replyBtn.onclick = () => startReply(msg._id, msg.message);
          actionBtns.appendChild(replyBtn);

          messageDiv.appendChild(actionBtns);
        } else {
          const actionBtns = document.createElement("div");
          actionBtns.classList.add("action-buttons");
          const replyBtn = document.createElement("button");
          replyBtn.classList.add("reply-btn");
          replyBtn.textContent = "↩";
          replyBtn.title = "Reply";
          replyBtn.onclick = () => startReply(msg._id, msg.message);
          actionBtns.appendChild(replyBtn);
          messageDiv.appendChild(actionBtns);
        }

        const clearDiv = document.createElement("div");
        clearDiv.classList.add("clear");
        container.appendChild(messageDiv);
        container.appendChild(clearDiv);
      });

      // Restore scroll position if the user was at the bottom
      if (isAtBottom) {
        container.scrollTop = container.scrollHeight;
      }
      // Else, maintain the current scroll position
    }

    /**
     * Initiates a reply to a specific message.
     * @param {String} msgId - The ID of the message being replied to.
     * @param {String} msgText - The text of the message being replied to.
     */
    function startReply(msgId, msgText) {
      currentReplyMsgId = msgId;
      currentReplyPreview = msgText.slice(0, 80);
      if (msgText.length > 80) currentReplyPreview += "...";
      document.getElementById("replyBanner").style.display = "block";
      document.getElementById("replyPreviewText").textContent = currentReplyPreview;
    }

    /**
     * Cancels the current reply action.
     */
    function cancelReply() {
      currentReplyMsgId = null;
      currentReplyPreview = null;
      document.getElementById("replyBanner").style.display = "none";
    }

    /**
     * Sends a new message.
     * @returns {Boolean} - Prevents default form submission.
     */
    function sendMessage() {
      const msgInput = document.getElementById("msgInput");
      const msgText = msgInput.value.trim();
      if (!msgText) return false;

      // Define the operation as an async function
      const operation = async () => {
        try {
          const payload = { token, receiver: otherUser, message: msgText };
          if (currentReplyMsgId) {
            payload.reply_to_msg_id = currentReplyMsgId;
            payload.reply_preview = currentReplyPreview;
          }

          console.log("Sending message:", payload);

          const response = await fetch("/send_message", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });

          if (response.status === 401) {
            console.warn("Unauthorized. Refreshing token and re-queuing sendMessage.");
            await refreshToken();
            queueRequest(operation); // Re-queue the send operation after token refresh
            return;
          }

          if (response.ok) {
            const data = await response.json();
            if (data.error) {
              alert("Error sending message: " + data.error);
            } else {
              console.log("Message sent successfully:", data);
              msgInput.value = "";
              cancelReply();
              await refreshMessages();
            }
          } else {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
        } catch (err) {
          console.error("sendMessage error:", err);
          alert("Failed to send message.");
        }
      };

      // Queue the send operation
      queueRequest(operation);

      return false; // Prevent default form submission
    }

    /**
     * Deletes a message.
     * @param {String} msgId - The ID of the message to delete.
     */
    function deleteMessage(msgId) {
      const confirmDelete = confirm("Are you sure you want to delete this message?");
      if (!confirmDelete) return;

      // Define the operation as an async function
      const operation = async () => {
        try {
          const payload = {
            node_name: nodeName,
            token: token,
            message_id: msgId
          };

          console.log("Deleting message:", payload);

          const response = await fetch("/delete_message_via_erlang", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });

          if (response.status === 401) {
            console.warn("Unauthorized. Refreshing token and re-queuing deleteMessage.");
            await refreshToken();
            queueRequest(operation); // Re-queue the delete operation after token refresh
            return;
          }

          if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

          const data = await response.json();
          if (data.error) {
            alert("Error deleting message: " + data.error);
          } else {
            console.log("Message deleted successfully:", data);
            await refreshMessages();  // Refresh the chat messages after deletion
          }
        } catch (err) {
          console.error("deleteMessage error:", err);
          alert("Failed to delete message.");
        }
      };

      // Queue the delete operation
      queueRequest(operation);
    }

    /**
     * Edits a message.
     * @param {String} msgId - The ID of the message to edit.
     * @param {String} oldText - The current text of the message.
     */
    function editMessage(msgId, oldText) {
      const newText = prompt("Edit your message:", oldText);
      if (!newText || newText.trim() === oldText) return;

      // Define the operation as an async function
      const operation = async () => {
        try {
          const payload = {
            node_name: nodeName,
            token: token,
            message_id: msgId,
            new_text: newText.trim()
          };

          console.log("Editing message:", payload);

          const response = await fetch("/edit_message_via_erlang", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });

          if (response.status === 401) {
            console.warn("Unauthorized. Refreshing token and re-queuing editMessage.");
            await refreshToken();
            queueRequest(operation); // Re-queue the edit operation after token refresh
            return;
          }

          if (response.ok) {
            const data = await response.json();
            if (data.error) {
              alert("Error editing message: " + data.error);
            } else {
              console.log("Message edited successfully:", data);
              await refreshMessages();  // Refresh the messages after editing
            }
          } else {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
        } catch (err) {
          console.error("editMessage error:", err);
          alert("Failed to edit message.");
        }
      };

      // Queue the edit operation
      queueRequest(operation);
    }

    /**
     * Toggles the block status of the other user.
     */
    function toggleBlock() {
      if (!nodeName) {
        console.error("Node name is missing! Cannot proceed.");
        alert("Error: Unable to process request due to missing node name.");
        return;
      }

      // Define the operation as an async function
      const operation = async () => {
        try {
          const payload = {
            node_name: nodeName,
            token: token,
            other_user: otherUser
          };

          console.log("Toggling block status:", payload);

          const resp = await fetch("/toggle_block_user_via_erlang", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });

          if (resp.status === 401) {
            console.warn("Unauthorized. Refreshing token and re-queuing toggleBlock.");
            await refreshToken();
            queueRequest(operation); // Re-queue the toggle block operation after token refresh
            return;
          }

          if (!resp.ok) {
            throw new Error(`HTTP error! Status: ${resp.status}`);
          }

          const data = await resp.json();
          if (data.error) {
            alert("Error: " + data.error);
          } else {
            console.log("Block status toggled successfully:", data);
            isBlocked = !isBlocked;  // Toggle block state
            updateBlockButton();  // Update UI
            updateSendButton();
            alert(data.message);
          }
        } catch (err) {
          console.error("toggleBlock error:", err);
          alert("Failed to toggle block status.");
        }
      };

      // Queue the toggle block operation
      queueRequest(operation);
    }

    /**
     * Checks the block status between users.
     */
    async function checkBlockStatus() {
      if (!nodeName) {
        console.error("Node name is missing! Cannot proceed.");
        return;
      }

      const payload = {
        node_name: nodeName,
        token: token,
        other_user: otherUser
      };

      console.log("Checking block status:", payload);

      try {
        const response = await fetch("/check_block_status_via_erlang", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        if (response.status === 401) {
          console.warn("Unauthorized. Refreshing token and re-queuing checkBlockStatus.");
          await refreshToken();
          queueRequest(checkBlockStatus); // Re-queue the check block status operation after token refresh
          return;
        }

        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

        const data = await response.json();
        if (!data || typeof data !== "object") {
          console.error("Invalid JSON response from Erlang:", data);
          return;
        }
        isBlocked = data.we_blocked_them;
        otherSideBlockedUs = data.they_blocked_us;
        console.log("Block status updated:", { isBlocked, otherSideBlockedUs });
        updateBlockButton();
        updateSendButton();
      } catch (err) {
        console.error("checkBlockStatus error:", err);
        throw err; // Re-throw to handle in the queue
      }
    }

    /**
     * Updates the text of the block/unblock button.
     */
    function updateBlockButton() {
      const btn = document.getElementById("blockBtn");
      btn.textContent = isBlocked ? "Unblock" : "Block";
    }

    /**
     * Refreshes the user's online status.
     */
    async function refreshUserStatus() {
      if (!nodeName) {
        console.error("Error: Node name is missing!");
        return;  // Do not throw to allow queue to continue
      }

      const payload = {
        node_name: nodeName,
        token: token,
        username: otherUser
      };

      console.log("Refreshing user status:", payload);

      try {
        const response = await fetch("/get_user_status_via_erlang", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        if (response.status === 401) {
          console.warn("Unauthorized. Refreshing token and re-queuing refreshUserStatus.");
          await refreshToken();
          queueRequest(refreshUserStatus); // Re-queue the refresh user status operation after token refresh
          return;
        }

        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const data = await response.json();
        if (!data || typeof data !== "object") {
          console.error("Invalid JSON response from server:", data);
          return;
        }
        updateStatusUI(data);
      } catch (err) {
        console.error("refreshUserStatus error:", err);
        throw err; // Re-throw to handle in the queue
      }
    }

    /**
     * Updates the user's status in the UI.
     * @param {Object} stData - Status data from the server.
     */
    function updateStatusUI(stData) {
      const statusSpan = document.querySelector(".chat-header .status");

      if (!stData || !stData.status) {
        statusSpan.textContent = "Status unavailable";
        statusSpan.style.color = "#555";
        return;
      }

      if (stData.status === "online") {
        statusSpan.textContent = "Online";
        statusSpan.style.color = "green";
      } else {
        let lastOnline = stData.last_online;
        if (!lastOnline || lastOnline === "Never") {
          statusSpan.textContent = "Offline";
          statusSpan.style.color = "gray";
        } else {
          const dt = new Date(lastOnline);
          const now = new Date();
          const diffMs = now - dt;
          const oneDayMs = 24 * 60 * 60 * 1000;
          let displayTime = "";

          if (diffMs < oneDayMs) {
            displayTime = dt.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          } else {
            displayTime = dt.toLocaleDateString([], { day: '2-digit', month: 'short', year: 'numeric' }) +
                ", " +
                dt.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          }
          statusSpan.textContent = "last seen " + displayTime;
          statusSpan.style.color = "gray";
        }
      }
    }

    /**
     * Fetches the user's profile picture.
     */
    function fetchProfilePicture() {
      const payload = {
        node_name: nodeName,
        token: token,
        username: otherUser
      };

      // Define the operation as an async function
      const operation = async () => {
        try {
          console.log("Fetching profile picture:", payload);
          const response = await fetch("/get_profile_picture_via_erlang", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });

          if (response.status === 401) {
            console.warn("Unauthorized. Refreshing token and re-queuing fetchProfilePicture.");
            await refreshToken();
            queueRequest(operation); // Re-queue the fetch profile picture operation after token refresh
            return;
          }

          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }

          const data = await response.json();
          if (data.error) {
            console.error("Error fetching profile picture:", data.error);
          } else {
            const profileImg = document.getElementById("profilePicture");
            
            // Make sure the profile picture is not null or empty
            if (data.profile_picture && data.profile_picture !== "/profile_pictures/default_profile.png") {
              profileImg.src = data.profile_picture;
              console.log("Profile picture updated to:", data.profile_picture);
            } else {
              console.log("Profile picture is still default. Data received:", data.profile_picture);
            }
          }
        } catch (err) {
          console.error("fetchProfilePicture error:", err);
          throw err; // Re-throw to handle in the queue
        }
      };

      // Queue the fetch profile picture operation
      queueRequest(operation);
    }

    /**
     * Initializes the chat by fetching necessary data.
     */
    function initialFetchChat() {
      queueRequest(async () => {
        try {
          await checkBlockStatus();
          await refreshMessages();
          await refreshUserStatus();
          await fetchProfilePicture();  // Ensure all operations complete
        } catch (err) {
          console.error("initialFetchChat error:", err);
        }
      });
    }
    /* -------------------------------------------------------------------------- */

    /* ------------------------- Periodic Auto-Refresh ------------------------- */
    /**
     * Sets up periodic auto-refresh of chat data.
     */
    function setupAutoRefresh() {
      setInterval(() => {
        // Always queue refresh operations, regardless of isProcessing
        queueRequest(async () => {
          try {
            await checkBlockStatus();
            await refreshMessages();
            await refreshUserStatus();
            await fetchProfilePicture(); // Ensure all operations complete
          } catch (err) {
            console.error("Auto-refresh error:", err);
          }
        });
      }, 6000); // Refresh every 6 seconds
    }
    /* -------------------------------------------------------------------------- */

    /* ----------------------------- Event Listeners ---------------------------- */
    document.addEventListener("DOMContentLoaded", () => {
      initialFetchChat();
      setupAutoRefresh();

      const blockBtn = document.getElementById("blockBtn");
      blockBtn.addEventListener("click", toggleBlock);
    });
    /* -------------------------------------------------------------------------- */
  </script>
</body>
</html>

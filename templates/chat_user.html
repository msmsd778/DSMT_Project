<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chat with {{ other_user }}</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f4f4f4;
      margin: 0;
      padding: 0;
    }

    .top-bar {
      height: 50px;
      background: #fafafa;
      border-bottom: 1px solid #ddd;
      position: relative;
    }
    .back-btn {
      position: absolute;
      left: 1rem;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      font-size: 1.6rem;
      cursor: pointer;
      color: #555;
      z-index: 10;
    }
    .back-btn:hover {
      color: #000;
    }

    .chat-container {
      width: 60%;
      max-width: 900px;
      margin: 1rem auto;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-direction: column;
      height: 80vh;
      overflow: hidden;
      position: relative;
    }

    .chat-header {
      display: flex;
      align-items: center;
      padding: 1rem;
      border-bottom: 1px solid #ddd;
      background-color: #fafafa;
      position: relative;
    }
    .chat-header img {
      width: 50px; height: 50px; border-radius: 50%;
      margin-right: 1rem; object-fit: cover; border: 2px solid #ccc;
    }
    .chat-header h2 {
      margin: 0; font-size: 1.4rem;
    }
    .chat-header .status {
      margin-left: 1rem; font-size: 0.9rem; color: #555;
    }
    .block-btn {
      background-color:rgb(220, 28, 28); border: none; color: white;
      padding: 0.4rem 0.8rem; border-radius: 4px; cursor: pointer;
      font-size: 0.9rem; position: absolute; right: 1rem; top: 1.2rem; z-index: 2;
    }
    .block-btn:hover {
      background-color:rgb(195, 16, 16);
    }

    .delete-chat-btn {
      background-color:rgb(174, 43, 34);
      border: none;
      color: white;
      padding: 0.4rem 0.8rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      position: absolute;
      right: 6rem;  /* Adjust as needed so it sits beside the block button */
      top: 1.2rem;
      z-index: 2;
    }
    .delete-chat-btn:hover {
      background-color:rgb(101, 23, 23);
    }

    .messages-wrapper {
      flex: 1; display: flex; flex-direction: column; overflow: hidden;
    }
    #messages-area {
      flex: 1; overflow-y: auto; padding: 1rem;
      display: flex; flex-direction: column; gap: 0.5rem;
      background-color: #f9f9f9; position: relative;
    }

    .message {
      display: flex; flex-direction: column;
      align-self: flex-start;
      padding: 0.8rem;
      border-radius: 6px;
      max-width: 70%;
      background-color: #fff;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .message.mine {
      align-self: flex-end;
      background-color: #e1ffc7;
      text-align: right;
    }
    .reply-preview {
      font-size: 0.9rem; color: #444;
      margin-bottom: 0.4rem; padding: 0.4rem;
      border-left: 2px solid #999; background-color: #f0f0f0;
      border-radius: 4px; margin-top: -0.2rem;
    }

    .message-content {
      display: flex; flex-direction: column; gap: 0.3rem;
    }
    .timestamp {
      font-size: 0.75rem; color: #999;
    }
    .read-receipt {
      font-size: 0.75rem; color: #999;
      margin-left: 0.5rem; margin-bottom: 0.3rem; display: inline-block;
    }

    .message-footer {
      display: flex; align-items: center; justify-content: space-between;
      margin-top: 0.3rem;
    }
    .action-buttons {
      display: flex; gap: 5px;
    }
    .delete-btn, .edit-btn, .reply-btn {
      background: none; border: none; cursor: pointer;
      font-size: 0.75rem; outline: none; padding: 2px 5px; border-radius: 3px;
      transition: background-color 0.2s ease;
    }
    .delete-btn { color: red; }
    .delete-btn:hover { background-color: rgba(255, 0, 0, 0.1); }
    .edit-btn { color: #007bff; }
    .edit-btn:hover { background-color: rgba(0, 123, 255, 0.1); }
    .reply-btn { color: #888; }
    .reply-btn:hover { background-color: rgba(136,136,136,0.1); }

    #replyBanner {
      display: none; padding: 0.5rem; background:rgb(184, 191, 198);
      border-left: 4px solid #ccc; margin: 0 1rem 1rem 1rem;
      position: relative;
    }
    #replyPreviewText {
      font-weight: bold; color: #333; margin-left: 5px;
    }

    #sendForm {
      display: flex; padding: 0.8rem;
      border-top: 1px solid #ddd; background-color: #fafafa; align-items: center;
    }
    #msgInput {
      flex: 1; padding: 0.5rem; font-size: 1rem;
      border: 1px solid #ccc; border-radius: 4px;
    }
    #sendBtn {
      padding: 0.5rem 1rem; margin-left: 0.5rem; font-size: 1rem;
      background-color: #4CAF50; color: white; border: none; border-radius: 4px;
      cursor: pointer; transition: background-color 0.3s ease;
    }
    #sendBtn:hover {
      background-color: #45a049;
    }
    #sendBtn:disabled {
      background-color: #ccc; cursor: not-allowed;
    }

    @media (max-width: 768px) {
      .chat-container { width: 95%; }
      .message { max-width: 80%; }
    }
  </style>
</head>
<body>
  <div class="top-bar">
    <button class="back-btn" onclick="window.location.href='/dashboard'" title="Back to Dashboard">&#8592;</button>
  </div>

  <div class="chat-container">
    <div class="chat-header">
      <img src="/profile_pictures/default_profile.png" alt="Profile Picture" id="profilePicture" />
      <div>
        <h2>{{ other_user }}</h2>
        <span class="status">
          {% if other_user_status == "online" %}
            Online
          {% elif other_user_status.startswith("last seen") %}
            {{ other_user_status }}
          {% else %}  
            Status unavailable
          {% endif %}
        </span>
      </div>
      <button class="block-btn" id="blockBtn">Block</button>
      <button class="delete-chat-btn" id="deleteChatBtn">Delete Chat</button>
    </div>

    <div id="replyBanner">
      Replying to:
      <span id="replyPreviewText"></span>
      <button onclick="cancelReply()" style="margin-left: 10px; cursor: pointer;">Cancel</button>
    </div>

    <div class="messages-wrapper">
      <div id="messages-area"></div>
    </div>

    <form id="sendForm" onsubmit="return sendMessage();">
      <input type="text" id="msgInput" placeholder="Type a message..." />
      <button type="submit" id="sendBtn">Send</button>
    </form>
  </div>

  <script>
    let requestQueue = [];
    let isProcessing = false;

    async function processQueue() {
      if (isProcessing || requestQueue.length === 0) return;
      isProcessing = true;
      const operation = requestQueue.shift();
      try {
        await operation();
      } catch (err) {
        console.error("Error processing request:", err);
      }
      isProcessing = false;
      processQueue();
    }

    function queueRequest(operation) {
      requestQueue.push(operation);
      console.log("Queued operation:", operation.name || "Anonymous Function");
      processQueue();
    }
    let token = {{ session['token']|tojson }};
    const otherUser = {{ other_user|tojson }};
    const currentUser = {{ username|tojson }};
    let nodeName = {{ node_name|tojson }};

    let refreshInProgress = false;
    let isBlocked = false;
    let otherSideBlockedUs = false;

    let currentReplyMsgId = null;
    let currentReplyPreview = null;

    function updateSendButton() {
      const sendBtn = document.getElementById("sendBtn");
      if (isBlocked || otherSideBlockedUs) {
        sendBtn.disabled = true;
      } else {
        sendBtn.disabled = false;
      }
    }

    async function refreshToken() {
      if (refreshInProgress) return;
      refreshInProgress = true;
      console.log("Refreshing token...");
      try {
        const resp = await fetch("/refresh_token", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ token: token })
        });
        const data = await resp.json();
        if (data.token) {
          token = data.token;
          console.log("Token refreshed.");
          await fetch("/update_token", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ token: token })
          });
        } else {
          console.warn("No token received during refresh.");
        }
      } catch (err) {
        console.error("refreshToken error:", err);
      } finally {
        refreshInProgress = false;
      }
    }

    async function refreshMessages() {
      const payload = {
        node_name: nodeName,
        token: token,
        other_user: otherUser
      };
  
      try {
        const response = await fetch("/get_messages_via_erlang", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
  
        if (response.status === 401) {
          console.warn("Unauthorized. Refreshing token and retrying fetchMessages.");
          await refreshToken();
          queueRequest(refreshMessages);
          return;
        }
  
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
  
        const data = await response.json();
        if (!data || typeof data !== "object" || !data.messages) {
          console.error("Invalid JSON response from server:", data);
          return;
        }
        renderMessages(data.messages);
  
      } catch (err) {
        console.error("refreshMessages error:", err);
      }
    }

    function renderMessages(messages) {
      const container = document.getElementById("messages-area");
      
      const isAtBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 100;
      
      container.innerHTML = "";

      messages.forEach(msg => {
        const isMine = (msg.sender === currentUser);
        const messageDiv = document.createElement("div");
        messageDiv.classList.add("message", isMine ? "mine" : "other");

        if (msg.reply_to && msg.reply_preview) {
          const replyDiv = document.createElement("div");
          replyDiv.classList.add("reply-preview");
          replyDiv.textContent = msg.reply_preview;
          messageDiv.appendChild(replyDiv);
        }

        const textSpan = document.createElement("span");
        textSpan.textContent = msg.message;
        messageDiv.appendChild(textSpan);

        if (msg.edited) {
          const editedSpan = document.createElement("span");
          editedSpan.textContent = " (edited)";
          editedSpan.style.fontStyle = "italic";
          editedSpan.style.fontSize = "0.8rem";
          messageDiv.appendChild(editedSpan);
        }

        const tsSpan = document.createElement("span");
        tsSpan.classList.add("timestamp");
        const msgDate = new Date(msg.timestamp);
        const now = new Date();
        const diffMs = now - msgDate;
        const oneDayMs = 24 * 60 * 60 * 1000;
        let formattedTime = "";
        if (diffMs < oneDayMs) {
          formattedTime = msgDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        } else {
          formattedTime = msgDate.toLocaleDateString([], {day: '2-digit', month: 'short', year: 'numeric'}) + ", " +
                          msgDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        }
        tsSpan.textContent = " " + formattedTime;
        messageDiv.appendChild(tsSpan);

        if (isMine) {
          const readReceipt = document.createElement("span");
          readReceipt.classList.add("read-receipt");
          if (msg.read_by && msg.read_by.includes(otherUser)) {
            readReceipt.textContent = "✔✔";
          } else {
            readReceipt.textContent = "✔";
          }
          messageDiv.appendChild(readReceipt);

          const actionBtns = document.createElement("div");
          actionBtns.classList.add("action-buttons");

          const delBtn = document.createElement("button");
          delBtn.classList.add("delete-btn");
          delBtn.textContent = "Delete";
          delBtn.onclick = () => deleteMessage(msg._id);
          actionBtns.appendChild(delBtn);

          const editBtn = document.createElement("button");
          editBtn.classList.add("edit-btn");
          editBtn.textContent = "Edit";
          editBtn.onclick = () => editMessage(msg._id, msg.message);
          actionBtns.appendChild(editBtn);

          const replyBtn = document.createElement("button");
          replyBtn.classList.add("reply-btn");
          replyBtn.textContent = "↩";
          replyBtn.title = "Reply";
          replyBtn.onclick = () => startReply(msg._id, msg.message);
          actionBtns.appendChild(replyBtn);

          messageDiv.appendChild(actionBtns);
        } else {
          const actionBtns = document.createElement("div");
          actionBtns.classList.add("action-buttons");
          const replyBtn = document.createElement("button");
          replyBtn.classList.add("reply-btn");
          replyBtn.textContent = "↩";
          replyBtn.title = "Reply";
          replyBtn.onclick = () => startReply(msg._id, msg.message);
          actionBtns.appendChild(replyBtn);
          messageDiv.appendChild(actionBtns);
        }

        const clearDiv = document.createElement("div");
        clearDiv.classList.add("clear");
        container.appendChild(messageDiv);
        container.appendChild(clearDiv);
      });

      if (isAtBottom) {
        container.scrollTop = container.scrollHeight;
      }
    }

    function startReply(msgId, msgText) {
      currentReplyMsgId = msgId;
      currentReplyPreview = msgText.slice(0, 80);
      if (msgText.length > 80) currentReplyPreview += "...";
      document.getElementById("replyBanner").style.display = "block";
      document.getElementById("replyPreviewText").textContent = currentReplyPreview;
    }

    function cancelReply() {
      currentReplyMsgId = null;
      currentReplyPreview = null;
      document.getElementById("replyBanner").style.display = "none";
    }


    function sendMessage() {
      const msgInput = document.getElementById("msgInput");
      const msgText = msgInput.value.trim();
      if (!msgText) return false;
  
      const operation = async () => {
        try {
          const payload = {
            node_name: nodeName,
            token: token,
            receiver: otherUser,
            message: msgText
          };
          if (currentReplyMsgId) {
            payload.reply_to_msg_id = currentReplyMsgId;
            payload.reply_preview = currentReplyPreview;
          }
  
          console.log("Sending private message (Erlang):", payload);
          const response = await fetch("/send_message_via_erlang", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });
          if (response.status === 401) {
            await refreshToken();
            queueRequest(operation);
            return;
          }
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
          const data = await response.json();
          if (data.error) {
            alert("Error sending message: " + data.error);
          } else {
            console.log("Message sent via Erlang:", data);
            msgInput.value = "";
            cancelReply();
  
            setTimeout(() => {
              queueRequest(refreshMessages);
            }, 300);
          }
        } catch (err) {
          console.error("sendMessage via Erlang error:", err);
          alert("Failed to send message.");
        }
      };
      queueRequest(operation);
  
      return false;
    }

    function deleteMessage(msgId) {
      const confirmDelete = confirm("Are you sure you want to delete this message?");
      if (!confirmDelete) return;

      const operation = async () => {
        try {
          const payload = {
            node_name: nodeName,
            token: token,
            message_id: msgId
          };

          console.log("Deleting message:", payload);

          const response = await fetch("/delete_message_via_erlang", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });

          if (response.status === 401) {
            console.warn("Unauthorized. Refreshing token and re-queuing deleteMessage.");
            await refreshToken();
            queueRequest(operation);
            return;
          }

          if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

          const data = await response.json();
          if (data.error) {
            alert("Error deleting message: " + data.error);
          } else {
            console.log("Message deleted successfully:", data);
            await refreshMessages();
          }
        } catch (err) {
          console.error("deleteMessage error:", err);
          alert("Failed to delete message.");
        }
      };

      queueRequest(operation);
    }

    function editMessage(msgId, oldText) {
      const newText = prompt("Edit your message:", oldText);
      if (!newText || newText.trim() === oldText) return;

      const operation = async () => {
        try {
          const payload = {
            node_name: nodeName,
            token: token,
            message_id: msgId,
            new_text: newText.trim()
          };

          console.log("Editing message:", payload);

          const response = await fetch("/edit_message_via_erlang", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });

          if (response.status === 401) {
            console.warn("Unauthorized. Refreshing token and re-queuing editMessage.");
            await refreshToken();
            queueRequest(operation);
            return;
          }

          if (response.ok) {
            const data = await response.json();
            if (data.error) {
              alert("Error editing message: " + data.error);
            } else {
              console.log("Message edited successfully:", data);
              await refreshMessages();
            }
          } else {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
        } catch (err) {
          console.error("editMessage error:", err);
          alert("Failed to edit message.");
        }
      };

      queueRequest(operation);
    }

    function deleteChat() {
      const confirmDelete = confirm("Are you sure you want to delete every message with this user?");
      if (!confirmDelete) return;
    
      const operation = async () => {
        try {
          const payload = {
            node_name: nodeName,
            token: token,
            other_user: otherUser
          };
          console.log("Deleting entire chat:", payload);
    
          const response = await fetch("/delete_chat_via_erlang", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });
    
          if (response.status === 401) {
            console.warn("Unauthorized. Refreshing token and re-queuing deleteChat.");
            await refreshToken();
            queueRequest(operation);
            return;
          }
    
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
    
          const data = await response.json();
          if (data.error) {
            alert("Error deleting chat: " + data.error);
          } else {
            alert("Chat deleted successfully.");
            window.location.href = "/dashboard";
          }
        } catch (err) {
          console.error("deleteChat error:", err);
          alert("Failed to delete chat.");
        }
      };
    
      queueRequest(operation);
    }


    function toggleBlock() {
      if (!nodeName) {
        console.error("Node name is missing! Cannot proceed.");
        alert("Error: Unable to process request due to missing node name.");
        return;
      }

      const operation = async () => {
        try {
          const payload = {
            node_name: nodeName,
            token: token,
            other_user: otherUser
          };

          console.log("Toggling block status:", payload);

          const resp = await fetch("/toggle_block_user_via_erlang", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });

          if (resp.status === 401) {
            console.warn("Unauthorized. Refreshing token and re-queuing toggleBlock.");
            await refreshToken();
            queueRequest(operation);
            return;
          }

          if (!resp.ok) {
            throw new Error(`HTTP error! Status: ${resp.status}`);
          }

          const data = await resp.json();
          if (data.error) {
            alert("Error: " + data.error);
          } else {
            console.log("Block status toggled successfully:", data);
            isBlocked = !isBlocked;
            updateBlockButton();
            updateSendButton();
            alert(data.message);
          }
        } catch (err) {
          console.error("toggleBlock error:", err);
          alert("Failed to toggle block status.");
        }
      };

      queueRequest(operation);
    }

    async function checkBlockStatus() {
      if (!nodeName) {
        console.error("Node name is missing! Cannot proceed.");
        return;
      }

      const payload = {
        node_name: nodeName,
        token: token,
        other_user: otherUser
      };

      console.log("Checking block status:", payload);

      try {
        const response = await fetch("/check_block_status_via_erlang", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        if (response.status === 401) {
          console.warn("Unauthorized. Refreshing token and re-queuing checkBlockStatus.");
          await refreshToken();
          queueRequest(checkBlockStatus);
          return;
        }

        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

        const data = await response.json();
        if (!data || typeof data !== "object") {
          console.error("Invalid JSON response from Erlang:", data);
          return;
        }
        isBlocked = data.we_blocked_them;
        otherSideBlockedUs = data.they_blocked_us;
        console.log("Block status updated:", { isBlocked, otherSideBlockedUs });
        updateBlockButton();
        updateSendButton();
      } catch (err) {
        console.error("checkBlockStatus error:", err);
        throw err;
      }
    }

    function updateBlockButton() {
      const btn = document.getElementById("blockBtn");
      btn.textContent = isBlocked ? "Unblock" : "Block";
    }

    async function refreshUserStatus() {
      if (!nodeName) {
        console.error("Error: Node name is missing!");
        return;
      }

      const payload = {
        node_name: nodeName,
        token: token,
        username: otherUser
      };

      console.log("Refreshing user status:", payload);

      try {
        const response = await fetch("/get_user_status_via_erlang", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        if (response.status === 401) {
          console.warn("Unauthorized. Refreshing token and re-queuing refreshUserStatus.");
          await refreshToken();
          queueRequest(refreshUserStatus);
          return;
        }

        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const data = await response.json();
        if (!data || typeof data !== "object") {
          console.error("Invalid JSON response from server:", data);
          return;
        }
        updateStatusUI(data);
      } catch (err) {
        console.error("refreshUserStatus error:", err);
        throw err;
      }
    }

    function updateStatusUI(stData) {
      const statusSpan = document.querySelector(".chat-header .status");

      if (!stData || !stData.status) {
        statusSpan.textContent = "Status unavailable";
        statusSpan.style.color = "#555";
        return;
      }

      if (stData.status === "online") {
        statusSpan.textContent = "Online";
        statusSpan.style.color = "green";
      } else {
        let lastOnline = stData.last_online;
        if (!lastOnline || lastOnline === "Never") {
          statusSpan.textContent = "Offline";
          statusSpan.style.color = "gray";
        } else {
          const dt = new Date(lastOnline);
          const now = new Date();
          const diffMs = now - dt;
          const oneDayMs = 24 * 60 * 60 * 1000;
          let displayTime = "";

          if (diffMs < oneDayMs) {
            displayTime = dt.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          } else {
            displayTime = dt.toLocaleDateString([], { day: '2-digit', month: 'short', year: 'numeric' }) +
                ", " +
                dt.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          }
          statusSpan.textContent = "last seen " + displayTime;
          statusSpan.style.color = "gray";
        }
      }
    }

    function fetchProfilePicture() {
      const payload = {
        node_name: nodeName,
        token: token,
        username: otherUser
      };

      const operation = async () => {
        try {
          console.log("Fetching profile picture:", payload);
          const response = await fetch("/get_profile_picture_via_erlang", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });

          if (response.status === 401) {
            console.warn("Unauthorized. Refreshing token and re-queuing fetchProfilePicture.");
            await refreshToken();
            queueRequest(operation);
            return;
          }

          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }

          const data = await response.json();
          if (data.error) {
            console.error("Error fetching profile picture:", data.error);
          } else {
            const profileImg = document.getElementById("profilePicture");
            
            if (data.profile_picture && data.profile_picture !== "/profile_pictures/default_profile.png") {
              profileImg.src = data.profile_picture;
              console.log("Profile picture updated to:", data.profile_picture);
            } else {
              console.log("Profile picture is still default. Data received:", data.profile_picture);
            }
          }
        } catch (err) {
          console.error("fetchProfilePicture error:", err);
          throw err;
        }
      };

      queueRequest(operation);
    }

    function initialFetchChat() {
      queueRequest(async () => {
        try {
          await checkBlockStatus();
          await refreshMessages();
          await refreshUserStatus();
          await fetchProfilePicture();
        } catch (err) {
          console.error("initialFetchChat error:", err);
        }
      });
    }
    function setupAutoRefresh() {
      setInterval(() => {
        queueRequest(async () => {
          try {
            await checkBlockStatus();
            await refreshMessages();
            await refreshUserStatus();
            await fetchProfilePicture();
          } catch (err) {
            console.error("Auto-refresh error:", err);
          }
        });
      }, 6000);
    }

    document.addEventListener("DOMContentLoaded", () => {
      initialFetchChat();
      setupAutoRefresh();

      const blockBtn = document.getElementById("blockBtn");
      blockBtn.addEventListener("click", toggleBlock);

      const deleteChatBtn = document.getElementById("deleteChatBtn");
      deleteChatBtn.addEventListener("click", deleteChat);
    });
  </script>
</body>
</html>

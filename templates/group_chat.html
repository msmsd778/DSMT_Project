<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Group Chat: {{ group_name }}</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f4f4f4;
      margin: 0;
      padding: 0;
    }
    .top-bar {
      height: 50px; background: #fafafa; border-bottom: 1px solid #ddd;
      position: relative;
    }
    .back-btn {
      position: absolute; left: 1rem; top: 50%; transform: translateY(-50%);
      background: none; border: none; font-size: 1.6rem; cursor: pointer; color: #555;
      z-index: 10;
    }
    .back-btn:hover { color: #000; }

    .chat-container {
      width: 60%; max-width: 900px;
      margin: 1rem auto;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      display: flex; flex-direction: column;
      height: 80vh; overflow: hidden; position: relative;
    }

    .chat-header {
      display: flex; align-items: center;
      padding: 1rem; border-bottom: 1px solid #ddd;
      background-color: #fafafa; position: relative; justify-content: space-between;
    }
    .chat-title { display: flex; flex-direction: column; }
    .chat-title h2 { margin: 0; font-size: 1.5rem; }
    .chat-members { font-size: 0.9rem; color: #555; margin-top: 0.3rem; }
    #membersCount { font-size: 0.9rem; color: #777; }

    .actions-area { display: flex; align-items: center; gap: 1rem; }
    .leave-group-btn {
      background-color: #f44336; color: white; border: none; border-radius: 4px;
      padding: 0.5rem 0.8rem; cursor: pointer;
    }
    .leave-group-btn:hover { background-color: #d32f2f; }
    .delete-group-btn {
      background-color: #af3232; color: white; border: none; border-radius: 4px;
      padding: 0.5rem 0.8rem; cursor: pointer;
    }
    .delete-group-btn:hover { background-color: #9b1e1e; }

    #ownerSelectContainer {
      display: none;
      align-items: center; gap: 0.5rem;
    }
    .owner-controls {
      display: none;
      flex-direction: column; align-items: flex-start;
      margin-bottom: 1rem; padding: 0 1rem;
    }
    .owner-controls label {
      font-weight: bold; margin-bottom: 0.3rem;
    }
    #searchUserInput { padding: 0.3rem; width: 200px; }
    #suggestions {
      position: relative; background-color: #f9f9f9; border: 1px solid #ccc;
      max-height: 120px; overflow-y: auto; display: none;
    }
    .suggestion-item {
      padding: 0.3rem; cursor: pointer;
    }
    .suggestion-item:hover { background-color: #eee; }

    .messages-wrapper {
      flex: 1; display: flex; flex-direction: column; overflow: hidden;
    }
    #messages-area {
      flex: 1; overflow-y: auto; padding: 1rem;
      display: flex; flex-direction: column;
      gap: 0.5rem;
      background-color: #f9f9f9;
      position: relative;
    }

    #replyBanner {
      display: none;
      padding: 0.5rem;
      background: rgb(184, 191, 198);
      border-left: 4px solid #ccc;
      margin: 0 1rem 1rem 1rem;
      position: relative;
    }
    #replyPreviewText {
      font-weight: bold; color: #333; margin-left: 5px;
    }

    .message {
      display: flex;     
      flex-direction: column;
      align-self: flex-start;
      padding: 0.8rem; margin-bottom: 0.5rem; border-radius: 6px;
      max-width: 70%; word-wrap: break-word;
      background-color: #fff;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .message.mine {
      align-self: flex-end; 
      background-color: #e1ffc7;
      text-align: right;
    }
    .message-content {
      display: flex; flex-direction: column; gap: 0.3rem;
    }
    .reply-preview {
      font-size: 0.9rem; color: #444; padding: 0.4rem;
      border-left: 2px solid #999; background-color: #f0f0f0;
      border-radius: 4px;
    }

    .message-footer {
      display: flex; align-items: center;
      justify-content: space-between;
      margin-top: 0.3rem;
    }
    .timestamp {
      font-size: 0.75rem; color: #999;
    }

    .action-buttons {
      display: flex; gap: 5px; margin-left: auto;
    }
    .delete-btn, .edit-btn, .reply-btn {
      background: none; border: none; cursor: pointer;
      font-size: 0.75rem; outline: none; padding: 2px 5px; border-radius: 3px;
      transition: background-color 0.2s ease;
    }
    .delete-btn { color: red; }
    .delete-btn:hover { background-color: rgba(255,0,0,0.1); }
    .edit-btn { color: #007bff; }
    .edit-btn:hover { background-color: rgba(0,123,255,0.1); }
    .reply-btn { color: #888; }
    .reply-btn:hover { background-color: rgba(136,136,136,0.1); }

    #sendForm {
      display: flex; padding: 0.8rem;
      border-top: 1px solid #ddd; background-color: #fafafa; align-items: center;
    }
    #msgInput {
      flex: 1; padding: 0.5rem; font-size: 1rem;
      border: 1px solid #ccc; border-radius: 4px;
    }
    #sendBtn {
      padding: 0.5rem 1rem; margin-left: 0.5rem; font-size: 1rem;
      background-color: #4CAF50; color: white;
      border: none; border-radius: 4px; cursor: pointer;
      transition: background-color 0.3s ease;
    }
    #sendBtn:hover { background-color: #45a049; }

    @media (max-width: 768px) {
      .chat-container { width: 95%; }
      .message { max-width: 80%; }
    }
  </style>
</head>
<body>
  <div class="top-bar">
    <button class="back-btn" onclick="window.location.href='/dashboard'" title="Back to Dashboard">&#8592;</button>
  </div>

  <div class="chat-container">
    <div class="chat-header">
      <div class="chat-title">
        <h2>{{ group_name }}</h2>
        <div class="chat-members" id="membersList">Members: (loading)</div>
        <div id="membersCount">Total: --</div>
      </div>
      <div class="actions-area">
        <div id="ownerSelectContainer">
          <label for="newOwnerSelect">Select New Owner:</label>
          <select id="newOwnerSelect"></select>
        </div>
        <button class="leave-group-btn" onclick="leaveGroup()">Leave Group</button>
        {% if owner == username %}
          <button class="delete-group-btn" onclick="deleteGroup()">Delete Group</button>
        {% endif %}
      </div>
    </div>

    <div class="owner-controls" id="ownerControls">
      <label for="searchUserInput">Search Username:</label>
      <input type="text" id="searchUserInput" placeholder="Type to search..." autocomplete="off" />
      <div id="suggestions"></div>
    </div>

    <div id="replyBanner">
      Replying to:
      <span id="replyPreviewText"></span>
      <button onclick="cancelReply()" style="margin-left:10px;cursor:pointer;">Cancel</button>
    </div>

    <div class="messages-wrapper">
      <div id="messages-area"></div>
    </div>

    <form id="sendForm" onsubmit="return sendMessage();">
      <input type="text" id="msgInput" placeholder="Type a message..." required />
      <button type="submit" id="sendBtn">Send</button>
    </form>
  </div>

  <script>
    let requestQueue = [];
    let isProcessing = false;
    async function processQueue() {
      if (isProcessing || requestQueue.length === 0) return;
      isProcessing = true;
      const operation = requestQueue.shift();
      try { await operation(); }
      catch (err) { console.error("Error processing request:", err); }
      isProcessing = false;
      processQueue();
    }
    function queueRequest(operation) {
      requestQueue.push(operation);
      processQueue();
    }

    let token = {{ session['token']|tojson }};
    let username = {{ username|tojson }};
    let groupName = {{ group_name|tojson }};
    let owner = {{ owner|tojson }};
    let isOwner = (owner === username);
    let groupMembers = {{ members|tojson }};
    let nodeName = {{ node_name|tojson }};
    let refreshInProgress = false;

    let currentReplyMsgId = null;
    let currentReplyPreview = null;

    const ownerControlsDiv = document.getElementById("ownerControls");
    if (isOwner) { ownerControlsDiv.style.display = "flex"; }

    function startReply(msgId, msgText) {
      currentReplyMsgId = msgId;
      currentReplyPreview = msgText.slice(0, 80);
      if (msgText.length > 80) currentReplyPreview += "...";
      document.getElementById("replyPreviewText").textContent = currentReplyPreview;
      document.getElementById("replyBanner").style.display = "block";
    }
    function cancelReply() {
      currentReplyMsgId = null;
      currentReplyPreview = null;
      document.getElementById("replyBanner").style.display = "none";
    }

    async function refreshToken() {
      if (refreshInProgress) return;
      refreshInProgress = true;
      try {
        const resp = await fetch("/refresh_token", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ token: token })
        });
        const data = await resp.json();
        if (data.token) {
          token = data.token;
          await fetch("/update_token", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ token: token })
          });
        } else {
          console.warn("Token refresh failed:", data);
        }
      } catch (err) {
        console.error("Error refreshing token:", err);
      } finally {
        refreshInProgress = false;
      }
    }

    const searchInput = document.getElementById("searchUserInput");
    const suggestionsDiv = document.getElementById("suggestions");
    searchInput.addEventListener("input", () => {
      const partial = searchInput.value.trim();
      if (!partial) {
        suggestionsDiv.style.display = "none";
        suggestionsDiv.innerHTML = "";
        return;
      }
      const formData = new URLSearchParams();
      formData.append("node_name", nodeName);
      formData.append("token", token);
      formData.append("query", partial);

      const operation = async () => {
        try {
          const resp = await fetch("/search_users_via_erlang", {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: formData
          });
          if (resp.status === 401) {
            await refreshToken();
            queueRequest(operation);
            return;
          }
          const data = await resp.json();
          if (data.error) {
            console.error("Error searching users:", data.error);
            suggestionsDiv.style.display = "none";
            return;
          }
          const foundUsers = data.users || [];
          if (foundUsers.length === 0) {
            suggestionsDiv.innerHTML = "<div class='suggestion-item'>No matches</div>";
            suggestionsDiv.style.display = "block";
          } else {
            suggestionsDiv.innerHTML = "";
            foundUsers.forEach(u => {
              const inGroup = groupMembers.includes(u);
              const item = document.createElement("div");
              item.classList.add("suggestion-item");
              item.textContent = (inGroup ? "Remove " : "Add ") + u;
              item.onclick = () => toggleMembership(u, inGroup);
              suggestionsDiv.appendChild(item);
            });
            suggestionsDiv.style.display = "block";
          }
        } catch (err) {
          console.error("search_users_via_erlang error:", err);
        }
      };
      queueRequest(operation);
    });
    function toggleMembership(targetUser, alreadyInGroup) {
      const endpoint = alreadyInGroup
        ? "/remove_user_from_group_via_erlang"
        : "/add_user_to_group_via_erlang";

      const operation = async () => {
        try {
          const payload = {
            node_name: nodeName,
            token: token,
            group_name: groupName,
            username: targetUser
          };
          const resp = await fetch(endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });
          if (resp.status === 401) {
            await refreshToken();
            queueRequest(operation);
            return;
          }
          const data = await resp.json();
          if (data.error) {
            alert(data.error);
          } else {
            queueRequest(fetchGroupMembers);
          }
          searchInput.value = "";
          suggestionsDiv.innerHTML = "";
          suggestionsDiv.style.display = "none";
        } catch (err) {
          console.error("toggleMembership error:", err);
        }
      };
      queueRequest(operation);
    }

    function fetchGroupMembers() {
      const operation = async () => {
        try {
          const url = `/get_group_members_via_erlang?node_name=${encodeURIComponent(nodeName)}&token=${encodeURIComponent(token)}&group_name=${encodeURIComponent(groupName)}`;
          const resp = await fetch(url);
          if (resp.status === 401) {
            await refreshToken();
            queueRequest(fetchGroupMembers);
            return;
          }
          const data = await resp.json();
          if (data.error) {
            console.error("Error fetching group members:", data.error);
            return;
          }
          groupMembers = data.members;
          owner = data.owner;
          isOwner = (owner === username);
          updateMembersUI();
        } catch (err) {
          console.error("fetchGroupMembers error:", err);
        }
      };
      queueRequest(operation);
    }
    function updateMembersUI() {
      const membersListEl = document.getElementById("membersList");
      const membersCountEl = document.getElementById("membersCount");
      membersListEl.innerHTML = "Members: ";
      groupMembers.forEach((m, index) => {
        if (m === owner) {
          membersListEl.innerHTML += `${m} (owner)`;
        } else {
          membersListEl.innerHTML += m;
        }
        if (index < groupMembers.length - 1) {
          membersListEl.innerHTML += ", ";
        }
      });
      membersCountEl.textContent = `Total: ${groupMembers.length}`;
      ownerControlsDiv.style.display = isOwner ? "flex" : "none";
    }

    function fetchGroupMessages() {
      const operation = async () => {
        try {
          const url = `/get_group_messages_via_erlang?node_name=${encodeURIComponent(nodeName)}&token=${encodeURIComponent(token)}&group_name=${encodeURIComponent(groupName)}`;
          const resp = await fetch(url);
          if (resp.status === 401) {
            await refreshToken();
            queueRequest(fetchGroupMessages);
            return;
          }
          const data = await resp.json();
          if (data.error) {
            console.error("Error fetching group messages:", data.error);
            return;
          }
          renderMessages(data.group_messages || []);
        } catch (err) {
          console.error("fetchGroupMessages error:", err);
        }
      };
      queueRequest(operation);
    }

    function formatTimestamp(isoStr) {
      const dt = new Date(isoStr);
      if (isNaN(dt)) return "N/A";
      const now = new Date();
      const diff = now - dt;
      const oneDayMs = 24 * 3600 * 1000;
      if (diff < oneDayMs) {
        return dt.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
      } else {
        return dt.toLocaleDateString([], { day: "2-digit", month: "short", year: "numeric" })
          + ", "
          + dt.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
      }
    }

    function renderMessages(messages) {
      const container = document.getElementById("messages-area");
      const isAtBottom = (container.scrollHeight - container.scrollTop - container.clientHeight) < 100;
      container.innerHTML = "";

      messages.forEach(msg => {
        const isMine = (msg.sender === username);
        const bubble = document.createElement("div");
        bubble.classList.add("message");
        if (isMine) bubble.classList.add("mine");

        const contentDiv = document.createElement("div");
        contentDiv.classList.add("message-content");

        if (msg.reply_to && msg.reply_preview) {
          const replyDiv = document.createElement("div");
          replyDiv.classList.add("reply-preview");
          replyDiv.textContent = msg.reply_preview;
          contentDiv.appendChild(replyDiv);
        }

        const textSpan = document.createElement("span");
        textSpan.textContent = msg.message;
        contentDiv.appendChild(textSpan);

        if (msg.edited) {
          const editedSpan = document.createElement("span");
          editedSpan.textContent = " (edited)";
          editedSpan.style.fontStyle = "italic";
          editedSpan.style.fontSize = "0.8rem";
          contentDiv.appendChild(editedSpan);
        }

        bubble.appendChild(contentDiv);

        const footerDiv = document.createElement("div");
        footerDiv.classList.add("message-footer");

        const tsSpan = document.createElement("span");
        tsSpan.classList.add("timestamp");
        tsSpan.textContent = formatTimestamp(msg.timestamp);
        footerDiv.appendChild(tsSpan);

        const canEditOrDelete = (msg.sender === username) || (owner === username);
        const actionBtns = document.createElement("div");
        actionBtns.classList.add("action-buttons");

        const replyBtn = document.createElement("button");
        replyBtn.classList.add("reply-btn");
        replyBtn.textContent = "↩";
        replyBtn.title = "Reply";
        replyBtn.onclick = () => startReply(msg._id, msg.message);
        actionBtns.appendChild(replyBtn);

        if (canEditOrDelete) {
          const editBtn = document.createElement("button");
          editBtn.classList.add("edit-btn");
          editBtn.textContent = "Edit";
          editBtn.onclick = () => editGroupMessage(msg._id, msg.message);
          actionBtns.appendChild(editBtn);

          const delBtn = document.createElement("button");
          delBtn.classList.add("delete-btn");
          delBtn.textContent = "Delete";
          delBtn.onclick = () => deleteGroupMessage(msg._id);
          actionBtns.appendChild(delBtn);
        }

        footerDiv.appendChild(actionBtns);
        bubble.appendChild(footerDiv);

        if (isMine) {
          const othersWhoRead = (msg.read_by || []).filter(r => r !== username);
          bubble.title = (othersWhoRead.length > 0) ? `Seen by: ${othersWhoRead.join(", ")}` : "Not seen yet";
        }

        container.appendChild(bubble);
      });

      if (isAtBottom) {
        container.scrollTop = container.scrollHeight;
      }
    }

    function sendMessage() {
      const msgInput = document.getElementById("msgInput");
      const msgText = msgInput.value.trim();
      if (!msgText) return false;

      const operation = async () => {
        try {
          const payload = {
            node_name: nodeName,
            token: token,
            group_name: groupName,
            message: msgText
          };
          if (currentReplyMsgId) {
            payload.reply_to_msg_id = currentReplyMsgId;
            payload.reply_preview = currentReplyPreview;
          }

          const resp = await fetch("/send_group_message_via_erlang", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });
          if (resp.status === 401) {
            await refreshToken();
            queueRequest(operation);
            return;
          }
          const data = await resp.json();
          if (data.error) {
            alert("Error sending group message: " + data.error);
          } else {
            msgInput.value = "";
            cancelReply();
            queueRequest(fetchGroupMessages);
          }
        } catch (err) {
          console.error("send_group_message_via_erlang error:", err);
          alert("Failed to send group message.");
        }
      };
      queueRequest(operation);
      return false;
    }

    function editGroupMessage(messageId, oldText) {
      const newText = prompt("Edit your message:", oldText);
      if (!newText || newText.trim() === oldText) return;

      const operation = async () => {
        try {
          const payload = {
            node_name: nodeName,
            token: token,
            group_name: groupName,
            message_id: messageId,
            new_text: newText.trim()
          };
          const resp = await fetch("/edit_group_message_via_erlang", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });
          if (resp.status === 401) {
            await refreshToken();
            queueRequest(operation);
            return;
          }
          const data = await resp.json();
          if (data.error) {
            alert("Error editing group message: " + data.error);
          } else {
            queueRequest(fetchGroupMessages);
          }
        } catch (err) {
          console.error("editGroupMessage error:", err);
          alert("Failed to edit group message.");
        }
      };
      queueRequest(operation);
    }

    function deleteGroupMessage(messageId) {
      const confirmDelete = confirm("Are you sure you want to delete this message?");
      if (!confirmDelete) return;

      const operation = async () => {
        try {
          const payload = {
            node_name: nodeName,
            token: token,
            group_name: groupName,
            message_id: messageId
          };
          const resp = await fetch("/delete_group_message_via_erlang", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });
          if (resp.status === 401) {
            await refreshToken();
            queueRequest(operation);
            return;
          }
          const data = await resp.json();
          if (data.error) {
            alert("Error deleting group message: " + data.error);
          } else {
            queueRequest(fetchGroupMessages);
          }
        } catch (err) {
          console.error("deleteGroupMessage error:", err);
          alert("Failed to delete group message.");
        }
      };
      queueRequest(operation);
    }

    function deleteGroup() {
      const confirmDel = confirm("Are you sure you want to delete the entire group? This cannot be undone.");
      if (!confirmDel) return;

      const operation = async () => {
        try {
          const payload = {
            node_name: nodeName,
            token: token,
            group_name: groupName
          };
          const resp = await fetch("/delete_group_via_erlang", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });
          if (resp.status === 401) {
            await refreshToken();
            queueRequest(operation);
            return;
          }
          const data = await resp.json();
          if (data.error) {
            alert("Error deleting group: " + data.error);
          } else {
            alert(data.message);
            window.location.href = "/dashboard";
          }
        } catch (err) {
          console.error("deleteGroup error:", err);
          alert("Failed to delete group.");
        }
      };
      queueRequest(operation);
    }

    function leaveGroup() {
      if (!isOwner) {
        removeUserFromGroup_viaErlang(username);
      } else {
        if (groupMembers.length < 2) {
          alert("You cannot leave if you are the only member. Consider deleting the group instead.");
          return;
        }
        const osc = document.getElementById("ownerSelectContainer");
        osc.style.display = "flex";
        const newOwnerSelect = document.getElementById("newOwnerSelect");
        newOwnerSelect.innerHTML = "";
        groupMembers.forEach(m => {
          if (m !== username) {
            const opt = document.createElement("option");
            opt.value = m;
            opt.textContent = m;
            newOwnerSelect.appendChild(opt);
          }
        });
        newOwnerSelect.onchange = () => {
          const chosenNewOwner = newOwnerSelect.value;
          if (!chosenNewOwner) return;
          reassignOwnershipAndLeave_viaErlang(chosenNewOwner);
        };
      }
    }
    function removeUserFromGroup_viaErlang(userToRemove) {
      const operation = async () => {
        try {
          const payload = {
            node_name: nodeName,
            token: token,
            group_name: groupName,
            username: userToRemove
          };
          const resp = await fetch("/remove_user_from_group_via_erlang", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });
          if (resp.status === 401) {
            await refreshToken();
            queueRequest(operation);
            return;
          }
          const data = await resp.json();
          if (data.error) {
            alert("Error removing user: " + data.error);
          } else {
            alert("You have left the group.");
            window.location.href = "/dashboard";
          }
        } catch (err) {
          console.error("removeUserFromGroup_viaErlang error:", err);
          alert("Failed to leave the group.");
        }
      };
      queueRequest(operation);
    }
    function reassignOwnershipAndLeave_viaErlang(newOwner) {
      const operation = async () => {
        try {
          const payload = {
            node_name: nodeName,
            token: token,
            group_name: groupName,
            new_owner: newOwner
          };
          const resp = await fetch("/reassign_group_owner_and_remove_via_erlang", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });
          if (resp.status === 401) {
            await refreshToken();
            queueRequest(operation);
            return;
          }
          const data = await resp.json();
          if (data.error) {
            alert("Error reassigning ownership: " + data.error);
          } else {
            alert(data.message);
            window.location.href = "/dashboard";
          }
        } catch (err) {
          console.error("reassignOwnershipAndLeave_viaErlang error:", err);
          alert("Failed to reassign ownership.");
        }
      };
      queueRequest(operation);
    }

    function setupAutoRefresh() {
      setInterval(() => {
        queueRequest(async () => {
          await fetchGroupMembers();
          await fetchGroupMessages();
        });
      }, 6000);
    }

    document.addEventListener("DOMContentLoaded", () => {
      queueRequest(async () => {
        await fetchGroupMembers();
        await fetchGroupMessages();
      });
      setupAutoRefresh();
    });
  </script>
</body>
</html>
